%\documentclass[conference]{IEEEtran}
%\documentclass[onecolumn]{article}
\documentclass{article}
\newcommand{\IEEEproof}{\proof}

\newcommand{\anote}[1]{{\color{magenta}[AM: #1]}}
\usepackage{amsmath,amsthm,amscd,amssymb}
\usepackage{verbatimbox}
\usepackage{multirow}
\usepackage{scalerel}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\DeclareUnicodeCharacter {9679}{\bullet}
\DeclareUnicodeCharacter {10214}{\llbracket }
\DeclareUnicodeCharacter {10215}{\rrbracket }
\DeclareUnicodeCharacter {8872}{\models}
\DeclareUnicodeCharacter {8871}{\models}

\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\usepackage{mathpartir}
\usepackage{color}
\usepackage{xspace}

\usepackage{listings} %include code in your document
\lstset{
  breaklines=true,
  extendedchars=true,
}
%\usepackage{algorithm2e}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

%\lstloadlanguages{Matlab} %use listings with Matlab for Pseudocode
%\lstnewenvironment{PseudoCode}[1][]
%{\lstset{language=Matlab,basicstyle=\scriptsize, keywordstyle=\color{blue},numbers=left,xleftmargin=.04\textwidth,#1}}{}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\ArgMin}{arg\,min}
\newcommand{\argmin}[1]{\displaystyle{\ArgMin_{#1}}}
\newcommand{\hash}{\mathcal{H}}
\newcommand{\Adv}{\mathcal{A}}
\newcommand{\tn}{\textnormal}
\newcommand{\unn}[1]{\uppercase\tn{#1}}
\newcommand{\samples}{\overset{\$}{←}}
\begin{document}

\title{Decentralized Storage from Scratch}

\maketitle

\begin{abstract}
  Bitcoin is widely regarded as the first broadly successful e-cash system. The main determinant of its success has been its attractive structure of incentives for participation that supposedly encourages ``decentralization,'' which roughly means that influence over the network (i.e., ``mining power'') tends to be dispersed among a large number of uncorrelated entities. However, to date, no model has been proposed in which ``decentralization'' can be clearly defined, which has made it difficult to evaluate whether Bitcoin's particular construction (or variations thereof) meets this goal.

We first introduce a simple economic game involving two types of rational (under Cumulative Prospect Theory) agents - clients and servers - that captures an intuitive notion of ``decentralization''. We derive Bitcoin's lottery-like incentive structure as a viable solution in this model. Surprisingly, we find that Bitcoin is decentralized only when participation is {\em unprofitable} on average.

Second, we find that Bitcoin's particular puzzle construction defeats the intended incentive structure; we demonstrate that the puzzle is amenable to ``outsourcing'', by which clients and servers enter into enforceable and mutually beneficial contracts, which leads to centralization. We construct a puzzle for which such contracts would inherently be unenforceable, under computational assumptions about the overhead of secure outsourcing.

Finally, we show that the benefits of decentralization extend beyond dispersing compute power amongst the participants; indeed, we show that incentivizing decentralization makes BitCoin a natural resource for reliable peer-to-peer storage. Our approach is to ``graft'' a Proof-of-Retrievability scheme into the puzzle, such that finding a solution requires access to a complete file copy. This also addresses an oft-cited drawback of Bitcoin, namely that the mining operation is wasteful. The ``goldrush'' towards competitive participation has led to manufacturing investment in specialized ``mining equipment,'' which is otherwise essentially useless. Our proposed modification {\em recycles} this investment, thereby reducing the system's overall waste.
\end{abstract}

\section{Scratch-Off Puzzles}

Scratch-off puzzles are moderately hard computational puzzles, used for constructing scratch-off lotteries. They are similar to proof-of-work puzzles and client puzzles, but differ in two ways: first, the puzzle should admit concurrent work, such that even a small amount of computation leads to a proportional chance of success; second, solving a scratch-off puzzle entitles the solver to associate a message with the solution. Associating a message with a solution allows the solver to claim or spend a reward. Our definition is adapted from the client-puzzles in \cite{chen2009security,stebila2011stronger}.

Let $ε_{d,k,n} : ℕ → \left[0,1\right]$ and $ω_{d,k} : ℕ → \left[0,1\right]$ be a family of functions, which will bound from below (resp., from above) the probability of puzzle-solving success from concurrent attempts by honest parties (resp., attempts by the adversary), where $d$ is a difficulty parameter, $k$ is a security parameter, and $n$ is a number of distinct puzzles.

\begin{definition}A scratch-off puzzle consists of two functions:
\begin{itemize}
\item $π ← \unn{scratch}(puz, m)$
\item  $\unn{verify}(puz, π, m) ∈ \{0,1\}$
\end{itemize}

satisfying the following properties:
\begin{itemize}
\item {\em (ω-Concurrent)} $\unn{scratch}(\cdot)$ is a probabilistic algorithm that takes at most $t₀$ steps. For any number $n$, and sequence of messages $\{m₁,m₂,...,m_n\}$, then the output of $n$ concurrent attempts, $π_i ← \unn{scratch}(puz,m_i)$ for $1 ≤ i ≤ n$, contains a winning solution (i.e., there exists an $\hat{i}$ such that $\unn{verify}(puz,π_{\hat i},m_{\hat i})$) with at least probability $ω_{d,k}(n)$.

\item {\em (ε-Strong)} Let $\{(puz₁,m₁),...,(puz_q,m_q)\}$ be an arbitrary sequence of messages and puzzles. Let $\Adv$ be an arbitrary adversary with unbounded oracle access to $\unn{scratch}(puz_i, m_i), 1 ≤ i ≤ q$, and at most $t$ additional steps. Then $\Adv$ computes $n$ solutions to distinct puzzles, $\{puz'₁,...,puz'_n\}$, with designated messages $\{m'₁,...,m'_m\}$, such that $∀(i,j)$, $(puz_i,m_i)≠(puz'_j,m'_j)$, with probability at most $ε_{d,k,n}(t)$.

\end{itemize}
\end{definition}

\begin{remark}
The ε-strong condition resembles non-malleability in digital signatures. It captures the property that the adversary cannot reuse the output of honest participants in order to more easily find a solution for a message of its choice.
\end{remark}

\begin{definition}A strong scratch-off puzzle satisfies the following condition on $ε$:
\begin{itemize}
  \item $|ε_{d,k,n}(t) - ε_{d,k,1}(t/n)| ≤ negl(k,d)$
\end{itemize}
\end{definition}

\begin{remark}
This captures the property that solving several puzzles is not easier or amortizable compared to solving a single puzzle.
\end{remark}

\begin{definition}A concurrent scratch-off puzzle satisfies the following condition on $ω$:
\begin{itemize}
  \item $|ω_{d,k}(n) - (1-(1-ω_{d,k}(1))^n)| ≤ negl(k,d)$
\end{itemize}
\end{definition}

\begin{remark}
This captures the property that $n$ independent concurrent scratch-off attempts each contribute an approximately equal chance of winning. The negligible difference accounts for the possibility that concurrent attempts may draw the same random coins twice.
\end{remark}

\subsection{Bitcoin is a scratch-off puzzle}

The Bitcoin puzzle scheme is as follows:
\begin{algorithmic}[0]
  \Function{attempt}{$puz,m$}
    \State nonce $\samples \{0,1\}^k$
    \State π ← nonce ∥ $m$
    \State \Return π
  \EndFunction
  \State
  \Function{verify}{$puz, π$}
    \State \Return {$\hash(puz || π) < 2^{-d}$}
  \EndFunction
\end{algorithmic}

\anote{todo: give the specific function families $ε$ and $ω$ that it satisfies}


\section{Storage Puzzles}

A storage puzzle is a variation of a scratch-off puzzle with an embedded proof-of-retrievability. Each scratch-off attempt requires accessing random blocks of an encoded file. If an adversary attempts to solve the puzzle while only storing a corrupt or incomplete file, it will have to abort many of its scratch-off attempts, lowering its overall effectiveness. We formalize this by relating the probability of extraction (i.e., successfully recovering the entire file from oracle transcripts) to the probability of computing a puzzle solution in $t$ steps.

\begin{definition} A storage puzzle is a scratch-off puzzle satisfying the following property:
\begin{itemize}
\item (extractable) If an adversary $\Adv$ runs in $t$ steps and produces a puzzle solution with probability $p$, then the file $F$ can be reconstructed with probability $γ_{d,k}(t)$.
\end{itemize}
\end{definition}
\anote{Need to clarify the shape of $γ$.}

\subsubsection{A Storage Puzzle}

The following is a storage puzzle:

\begin{algorithmic}[0]
 \State $F_1,...F_n$ are the $n$ blocks of a file $F$ we want stored
 \State $H_1,...H_n$ are ECC-encoded file blocks of $F$ such that the file can be reconstructed from any $αn$ blocks.
 \Function{attempt}{$puz,m$}
   \State nonce $\samples \{0,1\}^k$
   \State $q_0 ← \hash(puz ∥ 0 ∥ $nonce$ ∥ m)$
   \For{$i ← 1$ to $ℓ$}
      \State $b_i ← H_{q_{i-1} \mod n}$
      \State $q_i ← \hash(puz ∥ i ∥ $nonce$ ∥ b_i)$
   \EndFor
   \State \Return $\{q_0,...,q_ℓ\}, $nonce
  \EndFunction
\end{algorithmic}
\anote{I need to do the calculation for this, as a function of $\Adv$'s number of steps, the number of iterations and error correction parameters.}


\section{Preventing Outsourced Puzzle Solving}

We'd like for clients to solve puzzles themselves, rather than paying servers do it for them. Our approach is to make it difficult to delegate the puzzle securely.

\subsection{Stealable Puzzles}

A {\em billable-work} protocol for a scratch-off puzzle captures the notion of an enforceable contract between a server and a client that would enable them to make a mutually beneficial arrangement. A client is willing to pay a low-variance price in exchange for puzzle-solving work, where such work leads to a high-variance payoff distribution. The server prefers low-variance payoff overall; regardless of the outcome of the work (whether a  solution was found), the server would like to send the client a bill based on computational resources consumed. A billable work scheme is secure if the server can not present bills to the client while reusing the work for its own purposes.

\begin{definition}A billable-work scheme for a puzzle consists of four functions,
\begin{itemize}
\item $sk,pk ← gen(d,d₀,m)$
\item (bill, π) ← $\unn{attempt\_server}(puz, sk)$
\item $\unn{check\_bill}(puz, pk, $bill$) ∈ \{0,1\}$
\end{itemize}
satisfying the following requirements:
\begin{itemize}
\item {\em (feasible)} $\unn{attempt\_server}()$ takes $t₀$ steps and has at least a $ω_{d₀,k}(1)$ chance of outputting a valid bill, and at least a $ω_{d,k}(1)$ chance of outputting a valid puzzle solution associated with $m$.
\item {\em (non-stealable)} if an arbitrary adversary $\Adv_{\unn{attempt\_server}}()$ takes $t$ steps and outputs a bill with probability $z$, then the probability of it outputting a valid puzzle solution for $m'≠m$ (i.e., stolen work) is at most $ε_{d,k,1}(t - ε^{-1}_{d₀,k,1}(z))$ (where $ε^{-1}_{d,k,n}(z) = \argmin{t}(ε_{d,k,n}(t) ≥ z)$).
\end{itemize}
\end{definition}

\subsubsection{Bitcoin admits a billable-work scheme}

A billable-work scheme for the bitcoin puzzle consists of:

\begin{algorithmic}[0]
  \State
  \State $⊥ ← gen(d,d₀,m$)\Comment{no setup necessary}
  \State
  \Function{attempt\_server}{$puz, ⊥$}
    \State nonce $\samples \{0,1\}^k$
    \State bill ← nonce ∥ $m$
    \State \Return (bill, bill)
  \EndFunction
  \State
  \Function{check\_bill}{$puz, ⊥$, bill}
    \State nonce$ ∥  m' ← $bill
    \State \Return {($\hash(puz || $bill$) < 2^{-d₀}) ∧ (m' = m) $}
  \EndFunction
\end{algorithmic}


\subsubsection{A Variation of Bitcoin is Stealable}

Since we want to discourage outsourcing, we want to design a puzzle that does not admit such a protocol.

\begin{definition}A stealable puzzle is one for for which no {\em billable-work} scheme exists.
\end{definition}

We assume the existence of a signature scheme $gen,sign_{pk},verify_{pk}$, where the signing operation is a deterministic oracle.

\begin{algorithmic}[0]
  \Function{attempt}{$puz,m$}
    \State $sk,pk ← gen(1^k)$
    \State nonce $\samples \{0,1\}^k$
    \State $s₁ ← sign_{sk}(puz ∥ \tn{nonce})$
    \State $s₂ ← sign_{sk}(puz ∥ \tn{nonce} ∥ m)$
    \State \Return $(pk, \tn{nonce}, m, s₁, s₂)$
  \EndFunction
  \State
  \Function{verify}{$puz, π$}
    \State $(pk, \tn{nonce}, m, s₁, s₂)$
    \State assert $verify_{pk}(s₁, puz ∥ \tn{nonce})$
    \State assert $verify_{pk}(s₂, puz ∥ \tn{nonce} ∥ m)$
    \State \Return {$(\hash(puz || s₁) < 2^{-d})$}
  \EndFunction
\end{algorithmic}

\begin{theorem}
The scratch-off puzzle above is {\em stealable}.
\end{theorem}
\proof
(Informal) Suppose a billable work scheme exists. Then $\unn{Attempt\_Server}$ has a probability $p$ of producing a valid solution $π$, and therefore must make a minimum number of oracle queries indicated by $ε^{-1}_{d,k,n}(p)$. From these queries we can extract the secret key $sk$, and thus derive a solution $π'$ for arbitrary message $m'$.  \qed

\subsubsection{A Stealable Storage Puzzle}

\anote{our main construction goes here}


\subsection{Non-Outsourceable Puzzles}

A {\em watermarked billable-work} protocol for a puzzle captures a broader notion of enforceable contract. Even if the server is able to steal the reward, it may be discouraged from doing so for other reasons. In particular, if the server's work can be watermarked, such that any attempt to steal the reward would be a detectable breach of contract, then the client may be be able to rely on legal recourse.

Since we want to discourage outsourcing, we want to design a puzzle that does not admit such a protocol. Below we give a more formal definition of the puzzle and watermarked billable-work protocol.

Let $Bin(n,k,p) = \sum^k_{i=0}{n \choose i}p^i(1-p)^{n-i}$ be the probability of having $k$ or fewer successes out of $n$ independent trials, each with probability $p$ (i.e., the CDF of the Binomial distribution). Also let $Bin^{-1}(k,p,z) = \argmin{n}\left[Bin(n,k,p) ≤ 1-z \right]$ be the smallest number of trials needed to produce $k$ successes with at least probability $z$ (i.e., the inverse CDF of the Binomial distribution).



\begin{definition}A watermark-billable-work scheme for a puzzle consists of four functions,
\end{definition}
\begin{itemize}
\item $sk,pk ← gen(d,d₀)$
\item (bill, solution) ← $\unn{attempt\_server}($puzid, $sk$)
\item $\unn{check\_bill}($puzid, $pk$, bill) ∈ \{0,1\}
\item $\unn{detect\_watermark}($puzid, $pk$, solution) ∈ \{0,1\}
\end{itemize}
satisfying the following requirements:
\begin{itemize}
\item {\em (non-interference)} if an arbitrary adversary $\Adv_{\unn{attempt}}($puzid) (without $sk$) runs in $t$ steps, then it produces a valid solution bearing the watermark with probability strictly less than $(1-ε)2^{-d}$, where $ε>0$ is a constant.
\item {\em (feasible)} $\unn{attempt\_server}()$ takes $t$ steps and has at least a $2^{-d₀}$ chance of outputting a valid bill, and at least a $2^{-d}$ chance of outputting a valid puzzle solution.
\item {\em (detectable)} if an arbitrary adversary $\Adv_{\unn{attempt\_server}}()$ takes $qt$ steps and outputs a bill with probability $z$, then the probability of it outputting a valid puzzle solution that {\em evades} detection  (without the watermark) is at most $negl(λ)$ more than $Bin(q-t×Bin^{-1}(k,2^{-d₀},z), 1, 2^{-d})$.
\end{itemize}

\begin{definition}
A non-outsourceable puzzle is a puzzle for which no effective watermark-billable-work scheme exists.
\end{definition}

\subsubsection{Bitcoin is a watermarkable puzzle}

A watermark scheme for the bitcoin puzzle consists of:

\begin{algorithmic}[0]
  \State
  \State $sk,pk$ ← gen($d,d₀$)\Comment{a signature scheme}
  \State
  \Function{attempt\_server}{puzid, $sk$}
    \State nonce ← sample random
    \State data ← listen for transactions
    \State bill ← nonce ∥ data ∪ \{ trans. signed with sk \}
    \State \Return (bill, bill)
  \EndFunction
  \State
  \Function{check\_bill}{puzid, $pk$, bill}
    \State \Return {$\hash($puzid$ || $bill$) < 2^{-d₀}$}
  \EndFunction
  \State
  \Function{detect}{puzid, $pk$, solution}
     \State nonce ∥ data ← solution
     \State check that data contains a $pk$ signature
  \EndFunction
\end{algorithmic}

\subsubsection{A Zero Knowledge variation of the Bitcoin puzzle is not watermarkable}

Assume we have a NIZK scheme for arbitrary circuits that is computationally sound and statistically zero-knowledge (in security parameter λ).

\begin{algorithmic}[0]
 \State
 \Function{C}{(puzid, $m$), (nonce, $m'$)}
   \State assert $\hash($puzid ∥ nonce ∥ $m⊕m') < 2^{-d}$
 \EndFunction
 \State
 \Function{attempt}{puzid}
   \State nonce ← sample random
   \State $m$ ← listen for valid transactions
   \State π ← prove \Call{C}{(puzid, $m$), (nonce, $0^{|m|}$)}
   \Comment{hiding (nonce, $0^{|m|}$)}
   \State \Return (π, $m$)
 \EndFunction
 \State
 \Function{verify}{puzid, solution}:
    \State (π, $m$) ← solution
    \State check that π proves $C(($puzid, $m), \cdot)$
 \EndFunction
\end{algorithmic}

\begin{theorem}
The above scheme is non-outsourceable.
\end{theorem}
\IEEEproof 
Suppose the existence of functions $\unn{attempt\_server}$, $\unn{check\_bill}$, and $\unn{detect}$ satisfy the {\em feasible}, {\em detectable}, and {\em non-interference} properties of a watermark-billable-work scheme. We will show a contradiction by constructing a witness distinguisher for the NIZK scheme. First we note that $\unn{attempt}($puzid$)$ runs in $t$ steps, and therefore by {\em non-interference} produces a detectable solution with probability less than $(1-ε)2^{-d}$. Next we apply the extractability of the NIZK scheme to $\Adv_{\unn{attempt\_server}}$ and construct an alternate $\Adv'$, which we then show is distinguishable from $\Adv_{\unn{attempt}}$ yet differs only in its (hidden) witness.
\begin{algorithmic}[0]
  \State
  \Function{$\Adv'$}{puzid, $sk$}
     \State (bill, $(π', m')) ← \Adv_{\unn{attempt\_server}}($puzid, $sk$)
     \State (nonce, $m) ← \mathcal{E}_{\Adv_{\unn{attempt\_server}}}$($π'$, (puzid, $sk$))
     \State π ← prove \Call{C}{(puzid, $m$), (nonce, $m⊕m'$)}
     \State \Return (bill, $(π, m))$
  \EndFunction
\end{algorithmic}
 \anote{Assume that extraction preserves exactly the number $t$ of steps (not just polynomially related).}  $\Adv'$ also takes $t$ steps, and outputs a bill (and/or a solution) whenever $\Adv_{\unn{attempt\_server}}($puzid, $sk)$ does. Because $\Adv'$ is {\em feasible}, it outputs a solution with probability $2^{-d}$; since it is {\em detectable}, it outputs a watermarked solution with similar probability. Therefore $\unn{detect\_watermark}$ can be used to distinguish between $\unn{attempt}$ and $\Adv'$ with advantage $ε$. But $\Adv'$ differs from only $\Adv_{\unn{attempt}}$ in the choice of witness, so the distinguisher violates the statistical zero-knowledge property of the NIZK.
\qed

\subsubsection{A Non-Outsourceable Storage Puzzle}

\anote{The pinocchio-based zero-knowledge puzzle construction goes here}

\bibliographystyle{IEEEtran}
\bibliography{dispersion}


\appendix

\end{document}


\section{Introduction}

The challenge is twofold: (1) as the protocol is open to the
public, we cannot rely on strong pre-established identities associated
uniquely to each user (which would simplify the matter and is the
standard model in distributed computing); and (2) due to economies of
scale, computational tasks are generally performed more efficiently
when resources are aggregated rather than dispersed. 

To address (1), we adapt a technique pioneered by Bitcoin: our
mechanism takes the form of a computational puzzle-solving
competition. We design the puzzle in such a way that it can be solved
most effectively only by 
correctly following the protocol (i.e., by storing the correct
data). 

The second aspect of the challenge is more difficult. We must
essentially {\em prevent outsourcing}. Our approach is motivated by
the observation that customers do not inherently *trust* the cloud
service provider, but rather delegate responsibility to the 
service provider only when it is efficient to enforce contracts to
that effect. Thus we would aim for a puzzle-competition protocol that
precludes the existence of a side-protocol by which a service provider
can prove to a client (or, perhaps more importantly, a judge or other
third party) that it is doing the puzzle-solving work that benefits the 
client. This approach seems likely to be thwarted, however, by recent
results on efficient private and verifiable computation for arbitrary
computations. We will proceed by supposing the existence of a poly-log
lower bound for the prover efficiency (i.e., the service providers
costs) of outsourced computation. We then adapt an approach based on
{\em signets}~\cite{signets}, such that any {\em easier} method of
outsourcing (short of universal outsourcing) makes the client
vulnerable to the server --- if the client trusts the service provider
with its computation, it also trusts the service provider with the
monetary reward.

\subsection{How Bitcoin Works}

Brief overview, include links to Bitcoin primer, Bitter-to-Better, Kroll and Felten, etc.

\subsection{Proof-of-Work and Hashcash}

\subsection{General Structure of Puzzle Competitions}

The general protocol structure we’ve discussed involves having a
trusted central party generate and publish a puzzle description in
each epoch. The participants try to find compute solutions to send to
the central party; the first participant to find a solution earns a
reward and the epoch ends.
\newline
\newline

%% \begin{algorithm}[h]
%%  \SetKwFunction{KwVerify}{scratch\_off}
%%  \SetKwFunction{KwSolve}{solve}
%%  $F_1,...F_n$ are the blocks of the $n$-block file we want stored\;
%%  $puz ← \tn{gen\_puz}(F, λ, \tn{epoch})$\;
%%  $pk,sk$ ← gen\_key()\;
%%   \KwSolve{puz}{
%%    \While{not solved}{
%%      nonce ← draw\_ticket($puz,pk$)\;
%%      \If{scratch\_off(nonce,λ) is valid}{
%%        this is a winner
%%      }
%%    }
%%  }
%%  \caption{General form of puzzle}
%% \end{algorithm}


\section{Economic Model}

Our economic model is intended to provide a workable definition of ``decentralization,'' the defining characteristic of Bitcoin's design objectives. 

Our high-level model involves a game played by a population of
rational agents. Each participant decides how much money to invest and how to allocate it. 
Monetary rewards are disbursed to agents to encourage (correct) participation.  
The agents decide how to participate based on rational decision making (i.e., based on ordinal preference relations), and how to allocate computational resources.

\subsection{Cumulative Prospect Theory, Rationality of Gambling}

This is a model for rational behavior that accounts for why people play casino games and purchase lottery tickets.\cite{cpt}, \cite{cptaxiomatization}.

Relationship with Expected Utility, traditional model of rationality.

Three axioms 

Regressivity of lotteries, evidence from powerball \cite{powerball}

Empirical evidence for the shape of the weighting function ~\cite{gonzalez1999shape}.
A typical weighting function is given by Prelec ~\cite{prelec1998probability}, $w(p) = w⁺(p) + w⁻(p)$, where

\begin{equation}
  w⁺(p) = exp[-β⁺(-ln(p))^α]
\end{equation}
and
\begin{equation}
  w⁻(p) = exp[-β⁻(-ln(p))^α].
\end{equation}

This particular form satisfies additional axioms that refine CPT, specifically compound invariance~\cite{prelec1998probability}.

\subsection{Decentralization Lottery Game}

We model participation in Bitcoin by a game involving two types of players, {\em clients} and {\em servers}. The game represents a fixed interval of time (e.g., one week), during which each player decides how much money to invest in Bitcoin mining.
We assume that servers are risk-neutral and profit-maximizing (i.e., with a linear utility function and no probability distortion).
Clients are assumed to have functions of the typical shape (i.e., S-shaped probability weighting function that overweights unlikely events and underweights near-certain events).

However, in order to model economies of scale and the trend of cloud computing, we assume that the servers enjoy a cheaper price per unit of computation than the clients, parameterized by a constant factor, ρ.

Determine the protocol design by a prize amount $P$ and probability $E$.
Let $I$

\begin{theorem}
  For any valid parameters, $α, β⁺, β⁻$, characterizing the preference of the clients, there exists a lottery prize $P$ large enough that a unique Nash equilibrium exists such that the clients invest $X$ in mining.
\end{theorem}
\IEEEproof assumed \qed.

Let $C_S$ be the amount of computational power invested by the servers, and $C_C$ be the amount invested by the clients. Let $P$ be the prize amount, and $E$ is the average time between epochs, and let $z$ be a bounded time of an interval during which decisions are made. The benefit of investing marginally additional more computing power must be equal to the marginal benefit 






\subsection{Hosted Mining Protocol}

Protocol for hosted mining with ordinary Bitcoin.

A puzzle could be made that would allow an outsourcing arrangement to work even better. Under the current scheme, it is possible for the server to withhold winning solutions. This may not be significant enough concern to discourage outsourcing, since there is apparently no incentive for service provider to do so. Nevertheless, we may construct a puzzle consisting of two phases, which has essentially the same effectiveness, yet allows the client to unblind each partial solution as a fair attempt.

%% \begin{algorithm}[h]
%%   \DontPrintSemicolon
%%   \SetKwFunction{KwCheck}{verify}
%%   \SetKwFunction{KwScratch}{scratch\_off}
%% \KwScratch{prevblock,nonce,data}{:\;
%% \quad  $root ← \hash(data)$\;
%% \quad  $h ← \hash(prevblock ∥ root ∥ nonce)$\;
%% \quad  \Return $h < 2^{-d}$
%% }\;

%% \KwCheck{prevblock,solution}{
%%   \;
%% }\;
%%    \caption{Standard bitcoin puzzle}
%% \end{algorithm}

\subsection{Strawman Non-Outsourceable Puzzle }
We can design a puzzle where the receipt of the reward is bound after the puzzle. This allows the miner to steal the puzzle. However even if the reward can be stolen, stealing the reward is detectable. It would be possible, for example, for the service provider to post an insurance bond that will be automatically paid out if it is caught.

\subsection{Non-Outsourceable Puzzle}


\section{Grafted Proof-of-Storage Puzzle}

We discuss techniques for the {\em crowdsourcing} of
storage. While {\em outsourcing} is a popular approach for reducing
costs by exploiting economies of scale and amortization, our 
primary goal is fault tolerance by replicating storage to devices that
are maximally dispersed, both spatially and administratively.
Previous work has focused on enabling service providers to prove they
replicate data across multiple hard drives, thus defending against
random device failures. However, this does not defend against
correlated failures of multiple drives, such as a data-center fire, or
a the service provider going bankrupt. Our goal is to achieve the
replication of
storage across as many independent administrative domains as possible,
and thereby enjoy minimal correlation of failures. Our approach,
inspired by Bitcoin, is to construct a mechanism for rewarding
participation, such that many individual
users are incentivised to participate (and participate correctly).

\subsection{Proof-of-Retrievability}

\subsection{Grafted Proof-of-Retrievability Puzzle}

This is a construction that leads to a poor outcome
  where the rational agents just pay a central server to do all of the
  work and they proportionally receive the benefit. This resembles
  the current Bitcoin puzzle, except based on a proof of retrievability.

%% \begin{algorithm}[h]
%%  $F_1,...F_n$ are the blocks of the $n$-block file we want stored\;
%%  $puz ← \tn{gen\_puz}(F, λ, \tn{epoch})$\;
%%  $pk,sk$ ← gen\_key()\;
%%  $λ₁+λ₂ = λ$ are outsource parameters chosen by the client\;
%%  \While{not solved}{
%%    nonce ← draw\_ticket($puz,pk$)\;
%%    $q_1,...q_d ← $gen\_challenge($puz$,nonce)\;
%%    $w₁ ← \hash(puz ∥ \tn{nonce} ∥ F_{q_1} ∥ ... ∥ F_{q_d}) ∈ [0,1]$ \;
%%    $w₂ ← sign(sk, (puz ∥ \tn{nonce}))$ \;
%%    \If{$w₁ < 2^{-λ₁}$ and $w₂ < 2^{-λ₂}$}{
%%      this is a winner\;
%%      transmit $w₂$ and nonce\;
%%    }
%%  }
%%  \caption{Strawman puzzle for which there exists an efficient
%%    publicly verifiable outsourcing contract}
%% \end{algorithm}


\section{Implementation and Evaluation}

We implemented a proof of concept of a hosted Bitcoin mining system. This allows a server to prove to a client that it is doing work that can only benefit the client.

We implemented the repaired  proof 







\subsection{RSA-Hourglass PoR Puzzle for Dispersed Computation}

%% \begin{algorithm}[h]
%%  $F_1,...F_n$ are the blocks of the $n$-block file we want stored\;
%%  $puz ← \tn{gen\_puz}(F, λ, \tn{epoch})$\;
%%  $pk,sk$ ← gen\_key()\;
%%  $G_1,...,G_n$ are watermark-encoded blocks with $sk$\;
%%  $H_1,...,H_n$ are made by applying inverse RSA to $G$ with trapdoor $sk$\;
%%  \While{not solved}{
%%    nonce ← draw\_ticket($puz,pk$)\;
%%    $q_1,...q_d ← \tn{gen\_challenge}(puz,\tn{nonce})$\;
%%    $w ← \hash(puz ∥ \tn{nonce} ∥ H_{q_1} ∥ ... ∥ H_{q_d}) ∈ [0,1]$ \;
%%    \If{$w < 2^{-λ}$}{
%%      this is a winner\;
%%      transmit $pk$ and a zk proof that $H_{q_i}$ is constructed
%%      correctly (without revealing $sk$, i.e., $G$)\;
%%    }
%%  }
%%  \caption{Strawman puzzle for which there exists an efficient
%%    publicly verifiable outsourcing contract}
%% \end{algorithm}

\section{Partial and Unlinkable PoR Puzzle}

The goal of the partial and unlinkable puzzle is to allow an
individual participant with less than the capacity to store the entire
file to select only a subset of the blocks and store those. However,
the winning puzzle solution shouldn't be linkable to the particular
subset; as otherwise, to maintain privacy, the participant would have
to download a different subset immediately after winning.

%% \begin{algorithm}[h]
%%  $F_1,...F_n$ are the blocks of the $n$-block file we want stored\;
%%  $puz ← \tn{gen\_puz}(F, λ, \tn{epoch})$\;
%%  $pk,sk$ ← gen\_key()\;
%%  player selects a private identity (random seed) $a$\;
%%  secret PRF is $g_a(j) = f_a(j) \mod n = (j^a \mod p) \mod n$\;
%%  at setup, player stores $F_{g_a(2)} … F_{g_a(k+1)}$\;
%%  \While{not solved}{
%%    nonce ← random()\;
%%    $Y ← (g^a \ h^\tn{nonce})$\;
%%    $c_1,...c_d ← $ draw $d$ random elements $∈ 1...k$ using $Y$ as seed\;
%%    $q_1,...q_d ← g_a(c_1),...g_a(c_d)$\;
%%    $w ← \tn{zk\_sign}(sk, (puz ∥ \tn{nonce} ∥ F_{q_1} ∥ ... ∥ F_{q_d}))$\;
%%    \If{$w < 2^{-λ}$}{
%%      this is a winner\;
%%      transmit zk proof that $c$ matches $q$\;
%%    }
%%  }
%% \caption{Partial and unlinkable PoR puzzle}
%% \end{algorithm}

