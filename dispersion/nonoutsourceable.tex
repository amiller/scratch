%\documentclass[conference]{IEEEtran}
%\documentclass[onecolumn]{article}
\documentclass[]{article}
\newcommand{\IEEEproof}{\proof}


\newcommand{\elaine}[1]{{\footnotesize\bf\color{blue} [elaine: #1]}}
\newcommand{\anote}[1]{{\color{magenta}[AM: #1]}}
\usepackage{amsmath,amsthm,amscd,amssymb}
\usepackage{verbatimbox}
\usepackage{multirow}
\usepackage{scalerel}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\DeclareUnicodeCharacter {9679}{\bullet}
\DeclareUnicodeCharacter {10214}{\llbracket }
\DeclareUnicodeCharacter {10215}{\rrbracket }
\DeclareUnicodeCharacter {8872}{\models}
\DeclareUnicodeCharacter {8871}{\models}

\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}

\setlength{\parskip}{1pt}

%\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{remark}
\newtheorem{remark}{Remark}
\usepackage{color}
\usepackage{xspace}

\usepackage{listings} %include code in your document
\lstset{
  breaklines=true,
  extendedchars=true,
}
%\usepackage{algorithm2e}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{protocolj}
\newcommand{\pprotocol}[5]{
{\begin{figure*}[#4]
\begin{center}
\setlength{\protowidth}{.9\textwidth}
%\addtolength{\protowidth}{-3\intextsep}

\fbox{
        \small
        \hbox{\quad
        \begin{minipage}{\protowidth}
    \begin{center}
    {\bf #1}
    \end{center}
        #5
        \end{minipage}
        \quad}
        }
        \caption{\label{#3} #2}
\end{center}
\vspace{-4ex}
\end{figure*}
} }

\algrenewcommand\textproc[1]{\textsf{#1}}
\algrenewcommand\algorithmicfunction{{}}

%\lstloadlanguages{Matlab} %use listings with Matlab for Pseudocode
%\lstnewenvironment{PseudoCode}[1][]
%{\lstset{language=Matlab,basicstyle=\scriptsize, keywordstyle=\color{blue},numbers=left,xleftmargin=.04\textwidth,#1}}{}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\ArgMin}{arg\,min}
\newcommand{\argmin}[1]{\displaystyle{\ArgMin_{#1}}}
\newcommand{\hash}{\mathcal{H}}
\newcommand{\Adv}{\mathcal{A}}
\newcommand{\Chal}{\mathcal{C}}
\newcommand{\tn}{\textnormal}
\newcommand{\unn}[1]{\textnormal{\textsf{#1}}}
\newcommand{\samples}{\overset{\$}{←}}
\newcommand{\puz}{\textnormal{\textsf{puz}}}
\newcommand{\bill}{\textnormal{\textsf{bill}}}
\begin{document}

\title{Decentralized Storage from Scratch}

\maketitle

\begin{abstract}
  Bitcoin is widely regarded as the first broadly successful e-cash system. The main determinant of its success has been its attractive incentive structure that apparently encourages participation from diverse and independent entities. We provide the first formalization of this incentive structure (which we call a Scratch-off Lottery) along with a simple rational model under which we can evaluate whether such schemes lead to decentralized participation as desired.

An oft-cited concern is that Bitcoin's underlying mechanism (which we call a Scratch-off Puzzle), involves continuously attempting to solve computational puzzles, may be unnecessarily wasteful; the puzzle solutions are not intrinsically useful, nor is specialized puzzle-solving hardware useful for anything else. We propose an alternative Scratch-off Puzzle based on Proofs-of-Retrievability, such that solving the puzzle requires random access to a copy of a file. Participation in a Scratch-off Lottery based on this puzzle has the beneficial side effect of highly decentralized file storage, thereby reducing the system's overall waste. We use our rational model to show that the modified puzzle preserves the essential properties of the original Bitcoin puzzle. We also provide an implementation and experiments to demonstrate the practicality of this modification.

Finally, we suggest a more realistic rational model that accounts for outsourcing and economies-of-scale (i.e., cloud computing), in which the original scheme leads to an undesirable centralized (rather than decentralized) outcome. We show how to repair the puzzle and lottery scheme (including our storage side-effect) to achieve decentralized participation even in this model.

\end{abstract}

\section{Introduction}

\input{intro}
\input{related}
\input{requirement}
\input{scheme}

\subsection{Overview of Bitcoin}




\section{Proof of Storage Locality}

We initially define a proof of locality as a protocol between a verifier and a prover.

A proof of retrievability guarantees that a file can be extracted from the a successful prover. A RAFT is a proof of redundancy, relies on properties of a typical disk to guarantee that not only can the file be extracted, but that it is stored on sufficiently many redundant disks. A proof of storage locality is intended to guarantee that the file is stored on a file near the user, and not on a cloud server somewhere.

To begin with we review the standard definition of a proof of retrievability.

\begin{figure*}[h]
\centering
\fbox{
\begin{protocol}{2}
%\protocolheader{\underline{Pre-processing phase}}
\participants{\underline{Verifier}}{\underline{Prover}}
\tn{File}~ F = F₁,...,F_{n} & \sends{F} & \tn{Stores $F$ on local disk} \\
c \samples \{0,1\}^k, b \samples 1,...,n &  \sends{c,b} & \\
\tn{verify}(pk, π, c ∥ F_b)  & \receives{π} & π ← \tn{sign}(sk, c ∥ F_b) \\

\end{protocol}
}
\caption{Proof of Storage Locality Protocol}
\end{figure*}

\subsection{Adversarial Model}

As in RAFT, we model a restricted form of adversary where we constrain what choices the adversary can make. In particular, the adversary chooses what data to store on the local disk, $D$. We assume that $|D| = |F|$, meaning the local disk is large enough to store the entire file. We assume that the disk is static therefore $D$ suffices for the entire experiment. The prover's local computation is modeled by an interactive Turing machine $M_P$ that has bounded space; therefore the prover cannot store much of the file in its machine memory rather than the disk. Finally the cloud server is modeled by an interactive Turing machine $M_S$. Crucially, we assume there is a minimum latency $Δ_{min}$ between the prover and the cloud machines.

We assume the existence of a signature oracle, such that either $M_S$ calls the random oracle, or $M_P$ does, but there is no effective way for them to do so together (e.g., in a secure computation).

\section{Muli-User Protocol}




\section{Emergency Global Back-Up Storage Game}

Scenario: the Government shuts down, and the Library of Congress digital archives are unavailable! \anote{better explanation here? geographical disaster?}

\begin{enumerate}
\item (Setup Phase) Begin with a file to backup $F$ (an image of the LoC digital archives). A trusted dealer \anote{not right word} can encode the file as necessary and publish a digest.
\item (Operational Phase) A population of $n$ rational parties in the network play at a lottery participation game, which we will describe later. In the participation game each party decides how much of their budget to allocate towards participation (i.e., purchasing a hard drive) and chooses a computational strategy. Depending on the outcome of the lottery, a participant may receive a monetary reward. Potentially many such phases are completed.  \anote{may not be necessary at this point to have joining/leaving}.
  \begin{itemize}
  \item Participants are able to interact with a semi-trusted mirror in order to download portions of the file as necessary (the mirrors are trusted for availability but may send incorrect files)
  \item Several untrusted ``cloud temptation'' service providers that offer to help the user participate (e.g., by storing files on their behalf), and pass the rewards (minus their costs, which are discounted) to the participant
  \item No collusion or side-channel conversations between participants
  \item \anote{Assumptions necessary for monetary reward and puzzle master?}
  \end{itemize}
\item (Recovery Phase) At some point the game ends, and the semi-trusted mirrors (and any service providers) are removed. A challenger must be able to reconstruct the original file through interaction with the participants, who for the sake of this phase are assumed to be honest.
\end{enumerate}

High level description of our approach to the solution:
\begin{itemize}
\item Scratch-off puzzle lottery, that rewards participants for storing a subset of the file
\item Outsource prevention: latency, cost of bandwidth prevent user from scart
\end{itemize}


\section{Scratch-off Puzzles}

Scratch-off puzzles are moderately hard computational puzzles, used for constructing scratch-off lotteries. They are similar to proof-of-work puzzles and client puzzles, but differ in two ways: first, the puzzle should admit concurrent work, such that even a small amount of computation leads to a proportional chance of success; second, solving a scratch-off puzzle entitles the solver to associate a message with the solution. Associating a message with a solution allows the solver to claim or spend a reward. Our definition is adapted from the client-puzzles in \cite{chen2009security,stebila2011stronger}.

\begin{definition} {\bf (Scratch-off Puzzle)} An scratch-off puzzle (parameterized by security parameter $k$) consists of spaces $\{pSpace$, $sSpace$, $dSpace ⊆ ℝ₊$, $mSpace$\}, and three functions $\{\unn{Gen},\unn{Scratch},\unn{Verify}\}$ with the following descriptions:
\begin{itemize}
\item $\puz ← \unn{Gen}(d)$ takes as input a difficulty parameter ($d ∈ dSpace$), and generates a puzzle instance $\puz ∈ pSpace$
\item $π ← \unn{Scratch}(\puz, m)$ runs in $t₁$ steps, makes a single attempt at finding a puzzle solution $π ∈ sSpace ∪ \{⊥\}$ associated with $m ∈ mSpace$, returning $⊥$ if no solution is found
\item  $\{0,1\} ← \unn{Verify}(\puz, π, m)$ checks if π is a valid solution associated with $m$.
\end{itemize}.

Additionally, the puzzle must satisfy two requirements, {\em feasibility} and {\em difficulty}, which respectively relate an upper bound on the effectiveness of an adversary (solving multiple concurrent puzzles with oracle access to other solving parties) and a lower bound on the effectiveness of concurrent and independent clients following the prescribed algorithm to the function $ζ(n,t,d) : ℕ × ℕ × dSpace → \left[0,1\right]$ which corresponds to the probability of drawing $n$ successes out of $t$ identical independent Bernoulli trials, each with probability $2^{-d}$.

Assume that $t_k ∈ O(poly(k))$ is a fixed bound on the running time of any adversary.

\noindent {\sc Feasibility game (\unn{Feas})}. The feasibility game $\unn{Feas}^{\unn{SPuz}}_{\Adv,d}(t)$ for an adversary $\Adv$ and a challenger $\Chal$ consists of the following four stages:
\begin{enumerate}
\item challenger $\Chal$ generates a puzzle, $\puz ← \unn{Gen}(d)$
\item adversary $\Adv$ chooses $t$ messages $m₁,m₂,...,m_t$
\item challenger $\Chal$ executes $π_i ← \unn{Scratch}(\puz,m_i)$ for $1 ≤ i ≤ t$.
\item the outcome of the game is $\displaystyle \bigvee_{1≤i≤t} \unn{Verify}(\puz, π_i, m_i)$.
\end{enumerate}

The feasibility requirement (for $t ≤ t_k$) is that
\begin{equation*}
  \Pr\left[ \unn{Feas}^{\unn{SPuz}}_{\Adv,d}(t) = 1 \right] ≥ ζ(1,t,d) - ν(d,k)
\end{equation*}
for some fixed negligible function ν.

\noindent {\sc Non-Malleable Difficulty game (\unn{Diff})}. The non-malleable difficulty game $\unn{Diff}^{\unn{SPuz}}_{\Adv,d,n}(t)$ between an adversary $\Adv$ and challenger $\Chal$ consists of the following stages:
\begin{enumerate}
\item adversary $\Adv$ runs for $t$ steps and outputs a sequence of $n$ puzzles, messages and potential solutions, $\{(\puz_1, π_1, m_1),...,(\puz_n, π_n,m_n)\}$.
\item the outcome of the game is 1 iff all solutions returned by the adversary are valid and the puzzle/message pairs are unique, i.e., \begin{equation*} \displaystyle \bigwedge_{1≤i≤n} \left( \unn{Verify}(\puz_i, π_i, m_i) ∧ \left( \bigwedge_{1≤j≤q} (\puz_i,m_i) ≠ (\puz_j,m_j) \right) \right).\end{equation*}
\end{enumerate}

 \begin{equation*}
\Pr\left[ \unn{Diff}^{\unn{SPuz}}_{\Adv,d}(n,t) = 1 \right] ≤ ζ(n,t,d) + ν(d,k)
 \end{equation*}

\end{definition}

Unlike \cite{chen2009security,stebila2011stronger,groza2013cryptographic}, we do not require that a puzzle solution can be found in with probability $1$ in bounded time, or even that a solution necessarily exists for every instance.

This captures the property that $n$ independent concurrent scratch-off attempts each contribute an approximately equal chance of winning. The negligible difference accounts for the possibility that concurrent attempts may draw the same random coins twice.

Like \cite{stebila2011stronger}, our difficulty requirement is that puzzles are not amortizable, i.e., solving $n$ puzzles requires no fewer steps in expectation than $n$ times the expected number of steps to solve a single puzzle.

\subsection{Bitcoin is a scratch-off puzzle}

Let $\hash : \{0,1\}^* → \{0,1\}^k$ be a random oracle, and let $dSpace = \{0,1,2,...,2^k\}$, $sSpace = pSpace = \{0,1\}^k$, and let steps be counted as a number of oracle queries.

\begin{itemize}
\item \begin{algorithmic}[0]
  \Function{Gen}{$d,1^k$}:
     \Return $\puz \samples \{0,1\}^k$
  \EndFunction
\end{algorithmic}
\item \begin{algorithmic}[0]
  \Function{Scratch}{$\puz,m$}:
    \State π $\samples \{0,1\}^k$
    \If {$\hash(\puz ∥ d ∥ π ∥ m) < 2^{-d}$}
       \Return $π$
    \Else  ~\Return $⊥$
    \EndIf
  \EndFunction
  \end{algorithmic}
\item
 \begin{algorithmic}[0]
  \Function{Verify}{$\puz, π, m$}:
    \State \Return {$\hash(\puz ∥ d ∥ π ∥ m) < 2^{-d}$}
  \EndFunction
\end{algorithmic}
\end{itemize}

\begin{proposition}
Bitcoin is a scratch-off puzzle.
\end{proposition}
\proof The probability of any two invocations of $\unn{Scratch}$ sampling the same coins is vanishing in $k$. This is sufficient to satisfy the feasibility requirement. Similarly, the probability of the adversary guessing a correct solution without checking is vanishing in $d$, and the probability of the challenger generating two identical puzzles is vanishing in $k$. This is sufficient to satisfy the difficulty requirement.
 \qed

\subsection{Storage Puzzles}

A storage puzzle is a variation of a scratch-off puzzle with an embedded proof-of-retrievability. Each scratch-off attempt requires accessing random blocks of an encoded file. If an adversary attempts to solve the puzzle while only storing a corrupt or incomplete file, it will have to abort many of its scratch-off attempts, lowering its overall effectiveness. We formalize this by relating the probability of extraction (i.e., successfully recovering the entire file from oracle transcripts) to the probability of computing a puzzle solution in $t$ steps.

\begin{definition} A storage puzzle is a scratch-off puzzle satisfying the following property:
\begin{itemize}
\item (extractable) If an adversary $\Adv$ runs in $t$ steps and produces a puzzle solution with probability $p$, then the file $F$ can be reconstructed with probability $γ_{d,k}(t)$.
\end{itemize}
\end{definition}
\anote{Need to clarify the shape of $γ$.}

The following is a storage puzzle:

\begin{algorithmic}[0]
 \State $F_1,...F_n$ are the $n$ blocks of a file $F$ we want stored
 \State $H_1,...H_n$ are ECC-encoded file blocks of $F$ such that the file can be reconstructed from any $αn$ blocks.
 \Function{attempt}{$puz,m$}
   \State nonce $\samples \{0,1\}^k$
   \State $q_0 ← \hash(puz ∥ 0 ∥ $nonce$ ∥ m)$
   \For{$i ← 1$ to $ℓ$}
      \State $b_i ← H_{q_{i-1} \mod n}$
      \State $q_i ← \hash(puz ∥ i ∥ $nonce$ ∥ b_i)$
   \EndFor
   \State \Return $\{q_0,...,q_ℓ\}, $nonce
  \EndFunction
\end{algorithmic}
\anote{I need to do the calculation for this, as a function of $\Adv$'s number of steps, the number of iterations and error correction parameters.}


\subsection{Non-Outsourceable Puzzles}
We'd like for clients to solve puzzles themselves, rather than paying servers do it for them. Our approach is to make it difficult to delegate the puzzle securely.

\subsubsection{Billable Work}

A {\em billable-work} protocol for a scratch-off puzzle captures the notion of an enforceable contract between a server and a client that would enable them to make a mutually beneficial arrangement. A client is willing to pay a low-variance price in exchange for puzzle-solving work, where such work leads to a high-variance payoff distribution. The server prefers low-variance payoff overall; regardless of the outcome of the work (whether a  solution was found), the server would like to send the client a bill based on computational resources consumed. A billable work scheme is secure if the server can not present bills to the client while reusing the work for its own purposes.

\begin{definition}A billable-work scheme for a scratch-off puzzle $\unn{SPuz}$ consists of four functions,
\begin{itemize}
\item $sk,pk ← \unn{Gen}_\unn{SPuz}(d,d₀,m)$
\item $(\bill, π) ← \unn{ScratchServer}(\puz, sk)$
\item $\unn{CheckBill}(\puz, pk, \bill) ∈ \{0,1\}$
\end{itemize}
satisfying the following requirements:
\begin{itemize}
\item {\em (feasible)} $\unn{attempt\_server}()$ takes $t₀$ steps and has at least a $ω_{d₀,k}(1)$ chance of outputting a valid bill, and at least a $ω_{d,k}(1)$ chance of outputting a valid puzzle solution associated with $m$.
\item {\em (non-stealable)} if an arbitrary adversary $\Adv_{\unn{attempt\_server}}()$ takes $t$ steps and outputs a bill with probability $z$, then the probability of it outputting a valid puzzle solution for $m'≠m$ (i.e., stolen work) is at most $ε_{d,k,1}(t - ε^{-1}_{d₀,k,1}(z))$ (where $ε^{-1}_{d,k,n}(z) = \argmin{t}(ε_{d,k,n}(t) ≥ z)$).
\end{itemize}
\end{definition}

\subsubsection{Bitcoin admits a billable-work scheme}

A billable-work scheme for the bitcoin puzzle consists of:

\begin{algorithmic}[0]
  \State
  \State $⊥ ← gen(d,d₀,m$)\Comment{no setup necessary}
  \State
  \Function{attempt\_server}{$puz, ⊥$}
    \State nonce $\samples \{0,1\}^k$
    \State bill ← nonce ∥ $m$
    \State \Return (bill, bill)
  \EndFunction
  \State
  \Function{check\_bill}{$puz, ⊥$, bill}
    \State nonce$ ∥  m' ← $bill
    \State \Return {($\hash(puz || $bill$) < 2^{-d₀}) ∧ (m' = m) $}
  \EndFunction
\end{algorithmic}


\subsubsection{A Variation of Bitcoin is Non-Outsourceable}

Since we want to discourage outsourcing, we want to design a puzzle that does not admit such a protocol.

\begin{definition}{\bf (Malleable Scratch-off Puzzle)} 
\noindent {\sc Malleable Difficulty game (\unn{DiffM})}. The malleable difficulty game $\unn{DiffM}^{\unn{SPuz}}_{\Adv,d,n}(t)$ between an adversary $\Adv$ and challenger $\Chal$ consists of the following stages:
\begin{enumerate}
\item challenger $\Chal$ generates $n$ puzzles, $\puz_n ← \unn{Gen}(d,1^k)$
\item adversary $\Adv$ makes an unbounded number of oracle queries $\unn{OScratch}(\puz'_j,m'_j)$, for arbitrary choices of $\puz'_j,m'_j$. $\Adv$ may also take $t$ additional steps, arbitrarily interleaved with the oracle queries. $\unn{OScratch}$ records the transcript sequence $\{(\puz'_1,m'_1),...,(\puz'_q,m'_q)\}$.
\item adversary $\Adv$ returns a sequence of $n$ messages and potential solutions, $\{(m_1,π_1),...,(π_n,m_n)\}$.
\item the outcome of the game is 1 iff all solutions returned by the adversary are valid and the associated solutions are disjoint with those attempted by the oracle queries, i.e., \begin{equation*} \displaystyle \bigwedge_{1≤i≤n} \left( \unn{Verify}(\puz_i, π_i, m_i) ∧ \left( \bigwedge_{1≤j≤q} (\puz_i,m_i) ≠ (\puz'_j,m'_j) \right) \right).\end{equation*}
\end{enumerate}

The difficulty requirement (for $t ≤ t_k$) is that
 \begin{equation*}
\Pr\left[ \unn{DiffM}^{\unn{SPuz}}_{\Adv,d}(n,t) = 1 \right] ≤ ζ(n,t,d) + ν(d,k)
 \end{equation*}
\end{definition}

\begin{definition}A stealable puzzle is one for for which no {\em billable-work} scheme exists.
\end{definition}

We assume the existence of a signature scheme $gen,sign_{pk},verify_{pk}$, where the signing operation is a deterministic oracle.

\begin{algorithmic}[0]
  \Function{attempt}{$puz,m$}
    \State $sk,pk ← gen(1^k)$
    \State nonce $\samples \{0,1\}^k$
    \State $s₁ ← sign_{sk}(puz ∥ \tn{nonce})$
    \State $s₂ ← sign_{sk}(puz ∥ \tn{nonce} ∥ m)$
    \State \Return $(pk, \tn{nonce}, m, s₁, s₂)$
  \EndFunction
  \State
  \Function{verify}{$puz, π$}
    \State $(pk, \tn{nonce}, m, s₁, s₂)$
    \State assert $verify_{pk}(s₁, puz ∥ \tn{nonce})$
    \State assert $verify_{pk}(s₂, puz ∥ \tn{nonce} ∥ m)$
    \State \Return {$(\hash(puz || s₁) < 2^{-d})$}
  \EndFunction
\end{algorithmic}

\begin{theorem}
The scratch-off puzzle above is {\em stealable}.
\end{theorem}
\proof
(Informal) Suppose a billable work scheme exists. Then $\unn{Attempt\_Server}$ has a probability $p$ of producing a valid solution $π$, and therefore must make a minimum number of oracle queries indicated by $ε^{-1}_{d,k,n}(p)$. From these queries we can extract the secret key $sk$, and thus derive a solution $π'$ for arbitrary message $m'$.  \qed

\subsection{A Non-Outsourceable Storage Puzzle}

The notion of a non-outsourceable puzzle can be combined with our notion of storage puzzle. The following is our main construction:

\anote{our main construction goes here}


\section{Scratch-off Lottery}
An economic model exploring the incentive structures supported by scratch-off lotteries.

Consider the following game involving $n$ rational participants. The game consists of two phases, a negotiation phase and an execution phase. In the negotiation phase, each player $P_i$ has an identical budget $b_{max}$, and must make a purchasing decision $0 ≤ b_i ≤ b_{max}$, which represents the amount of computational power $P_i$ controls in the execution phase. We will explain the execution phase before describing the negotiation phase in more detail. The execution phase consists of an unbounded number of rounds. The execution phase depends on fixed common-knowledge parameters $J$ (the maximum monetary reward), $E$ (the expected number of rounds in the execution phase), and $Δ$ (the maximum communication latency), as well as parameters that are chosen during the negotiation phase, $d$, and $0 ≤ Δ_i ≤ Δ$. Each round $r$ of the execution phase proceeds as follows:
\begin{enumerate}
\item A puzzle is generated with the indicated difficulty, $\puz ← \unn{Gen}(d)$.
\item In every round, each player $P_i$ makes $b_i$ invocations of $\unn{Scratch}(\puz,m_i)$, where each player's message $m_i$ is their public identifier. The order in which the steps are taken is determined by an arbitrary adversarial scheduler, $\Adv$.
\item If a player $P_i$ computes a valid solution, then an item $(i,r+Δ_i)$ is stored in a array.
\item The execution phase ends when the array contains an item matching the current round number, $(i,r)$. If multiple items match the round number, then only the first one wins. The corresponding player $P_i$ receives the jackpot, thus $b_{max}-b_i+J$ in total. Every other player $P_j$ receives nothing, so $b_{max}-b_j$.
\end{enumerate}

The negotiation phase consists of an unbounded number of rounds, and proceeds as follows:
\begin{enumerate}
\item Every player's bid, $b_i$, is initially set to zero.
\item In each round, the adversarial scheduler permutes the players arbitrarily. In order, each player $P_i$ is told the current total statistic, $b_{tot} = \displaystyle \sum_j b_j$. The player can leave her bid $b_i$ unchanged, or change it to any value between $0$ and $b_{max}$.
\item The negotiation phase concludes if in a round all players leave their bids unchanged.
\item If the negotiation phase concludes, then afterwards the adversary chooses each $Δ_i$, and sets $2^d = E\cdot b_{tot}$.
\end{enumerate}

We assume that the players are risk neutral, and therefore attempt to maximize their expected profit only. Although the delay parameters $Δ_i$ are unknown to the players during negotiation, we assume that their decision function may be modeled as though they have an arbitrary belief distribution assigning a probability density to every potential value for $Δ_i$. We also assume non-collusion between the players, such that they have no communication channels between them.

Suppose we have a participation target, given as $\hat{n} ≤ n$, indicating that we would like for at least $\hat{n}$ players each to contribute at least $b_i ≥ 1$. We now argue a positive result, that for every participation target, and environment parameters $Δ$ and $b_{max}$, there exists a parameter choice for $E$ and $J$ that satisfies the participation target.

\begin{proposition}
Fix the environment parameters $n$, $Δ$ and $b_{max}$, as well as the participation target $\hat{n}≤n$. Then there exist parameters $E$ and $J$ such that every equilibrium (if any exist) reaches the participation target.
\end{proposition}
\proof We can choose $E>0$ arbitrarily and calculate a suitable $J$. Suppose during a round of negotiation that fewer than $\hat{n}$ participants have positive bids. Then $b_{tot} ≤ \hat{n}\cdot b_{max}$. Consider the decision made by a player $P_i$ whose current bid is zero. If she were to increment her bid, then the probability that she would win is at least bounded below by the joint probability that she finds a solution in the first round, and no one else finds a solution for $Δ$ rounds. The probability that everyone else loses for $Δ$ consecutive rounds is at least $p₁ = Bin\left(0,\hat{n}\cdot b_{max}, \left(E(\hat{n}\cdot b_{max}+1)\right)^{-1}\right)$. The probability that she wins in the first round is at least $p₂ = \left(E(\hat{n}\cdot b_{max}+1)\right)^{-1}$. By setting $J > (p₁p₂)^{-1}$, the expected return from a nonzero bid is positive, even given the pessimistic beliefs. Thus any configuration that does not satisfy the participation target is not an equilibrium. \qed

\subsection{Security Analysis}

Here we relate the scratch-off lottery, instantiated with our non-outsourceable storage puzzle, to our backup storage game, and argue that under the conditions listed, it is secure.

\section{Implementation and Experiments}

\section{Discussion}
Ways of weakening the model so it's more realistic

\section{Conclusion}




\bibliographystyle{IEEEtran}
\bibliography{dispersion}


\appendix


\section{Other economic models}



\subsection{More Realistic Economic Models}

\subsubsection{Risk Neutral Model with 2 Types}

The above model demonstrates establishes a notion of participation as a protocol goal, and the effectiveness of an incentive scheme at achieving this. However we relied on an assumption of homogeneous preferences. In order to describe a notion of decentralization, we need to further refine the model in order to express trends like the aggregation of computational resources due to greater efficiency in economies of scale.

Consider a refinement of the model above, involving two types of players, servers and clients. We assume that servers have proportionally cheaper access to computational (by a constant factor $c < 1$) and unbounded budgets, and that servers have zero communication latency. The participation target is expressed as a desired number of clients. The payoff to a winning server is thus $-c\cdot b_i + \cdot J$.

\begin{proposition}
In the lottery game above, with two types of participants clients and servers, where servers have no latency and participation is discounted by factor $c < 1$, then there is no equilibrium in which any client participates.
\end{proposition}
\proof
Suppose for contradiction such an equilibrium exists. Then consider a server presented with the option of incrementing its participation bid. Since the current value $b_i$ is assumed to equilibrium, the incremental cost of one unit of participation must be no smaller than the expected payoff. Now suppose a client with a positive amount $b_j > 0$ considers decrementing his bid. Even if the client is fully optimistic and believes $Δ_j = 0$, the payoff for a jackpot is no greater than that of a server, yet the cost of participation is strictly higher. Therefore the client prefers to decrement the bid.
\qed

\subsubsection{CPT Model with 2 Types}

This is a model for rational behavior that accounts for why people play casino games and purchase lottery tickets.\cite{cpt}, \cite{cptaxiomatization}. Regressivity of lotteries, evidence from powerball \cite{powerball}. Empirical evidence for the shape of the weighting function ~\cite{gonzalez1999shape}.

For simplicity, we consider only the most restricted form, expected utility plus one parameter, $0 < α < 1$, given by Prelec: ~\cite{prelec1998probability}
\begin{equation}
  w(p) = exp\left[(-ln(p))^α\right]
\end{equation}

This particular representation can be derived from additional axioms that refine CPT, specifically compound invariance, diagonal concavity, subproportionality.

We assume that $α$ applies only to clients, and that for servers $α_{servers} = 1$, which means that the server's decision making is identical to the expected-profit-maximizing version from the previous model.

\begin{proposition}
For the scratch-off lottery game described above, where clients' decision making is parameterized by $0 < α < 1$ and servers maximized expected profits, if $c < f(α)$ then there exists a choice of parameters $E$ and $J$ such that any equilibrium achieves the participation target.
\end{proposition}
\proof 
  The slope of $w(p)$ as $p$ approaches zero becomes steeper without bound. It is therefore possible to choose $J$ large enough that $w(p)>c^{-1}$. $E$ can be set arbitrarily large so that the effect of latency $Δ$ is negligible, and thus the expected cost of funding the lottery, $J/E$, is arbitrarily small.
\qed

There are, unfortunately, numerous concerns about this model. One is that the extreme behavior of the weighting function at very small probabilities seems implausible. Another is that this does not account for any diminishing utility of wealth. Although in Bitcoin, the protocol itself defines how money is printed and therefore the bankroll may be arbitrarily large, an unbounded jackpot size implies that a player might win *all* the money. The more general form of the function we've accounted for corrects for this by having a value function (mapping monetary profit to utility) that exhibits diminishing returns.




\subsection{Non-Outsourceable Puzzles}

A {\em watermarked billable-work} protocol for a puzzle captures a broader notion of enforceable contract. Even if the server is able to steal the reward, it may be discouraged from doing so for other reasons. In particular, if the server's work can be watermarked, such that any attempt to steal the reward would be a detectable breach of contract, then the client may be be able to rely on legal recourse.

Since we want to discourage outsourcing, we want to design a puzzle that does not admit such a protocol. Below we give a more formal definition of the puzzle and watermarked billable-work protocol.

Let $Bin(n,k,p) = \sum^k_{i=0}{n \choose i}p^i(1-p)^{n-i}$ be the probability of having $k$ or fewer successes out of $n$ independent trials, each with probability $p$ (i.e., the CDF of the Binomial distribution). Also let $Bin^{-1}(k,p,z) = \argmin{n}\left[Bin(n,k,p) ≤ 1-z \right]$ be the smallest number of trials needed to produce $k$ successes with at least probability $z$ (i.e., the inverse CDF of the Binomial distribution).



\begin{definition}A watermark-billable-work scheme for a puzzle consists of four functions,
\end{definition}
\begin{itemize}
\item $sk,pk ← gen(d,d₀)$
\item (bill, solution) ← $\unn{attempt\_server}($puzid, $sk$)
\item $\unn{check\_bill}($puzid, $pk$, bill) ∈ \{0,1\}
\item $\unn{detect\_watermark}($puzid, $pk$, solution) ∈ \{0,1\}
\end{itemize}
satisfying the following requirements:
\begin{itemize}
\item {\em (non-interference)} if an arbitrary adversary $\Adv_{\unn{attempt}}($puzid) (without $sk$) runs in $t$ steps, then it produces a valid solution bearing the watermark with probability strictly less than $(1-ε)2^{-d}$, where $ε>0$ is a constant.
\item {\em (feasible)} $\unn{attempt\_server}()$ takes $t$ steps and has at least a $2^{-d₀}$ chance of outputting a valid bill, and at least a $2^{-d}$ chance of outputting a valid puzzle solution.
\item {\em (detectable)} if an arbitrary adversary $\Adv_{\unn{attempt\_server}}()$ takes $qt$ steps and outputs a bill with probability $z$, then the probability of it outputting a valid puzzle solution that {\em evades} detection  (without the watermark) is at most $negl(λ)$ more than $Bin(q-t×Bin^{-1}(k,2^{-d₀},z), 1, 2^{-d})$.
\end{itemize}

\begin{definition}
A non-outsourceable puzzle is a puzzle for which no effective watermark-billable-work scheme exists.
\end{definition}

\subsubsection{Bitcoin is a watermarkable puzzle}

A watermark scheme for the bitcoin puzzle consists of:

\begin{algorithmic}[0]
  \State
  \State $sk,pk$ ← gen($d,d₀$)\Comment{a signature scheme}
  \State
  \Function{attempt\_server}{puzid, $sk$}
    \State nonce ← sample random
    \State data ← listen for transactions
    \State bill ← nonce ∥ data ∪ \{ trans. signed with sk \}
    \State \Return (bill, bill)
  \EndFunction
  \State
  \Function{check\_bill}{puzid, $pk$, bill}
    \State \Return {$\hash($puzid$ || $bill$) < 2^{-d₀}$}
  \EndFunction
  \State
  \Function{detect}{puzid, $pk$, solution}
     \State nonce ∥ data ← solution
     \State check that data contains a $pk$ signature
  \EndFunction
\end{algorithmic}

\subsubsection{A Zero Knowledge variation of the Bitcoin puzzle is not watermarkable}

Assume we have a NIZK scheme for arbitrary circuits that is computationally sound and statistically zero-knowledge (in security parameter λ).

\begin{algorithmic}[0]
 \State
 \Function{C}{(puzid, $m$), (nonce, $m'$)}
   \State assert $\hash($puzid ∥ nonce ∥ $m⊕m') < 2^{-d}$
 \EndFunction
 \State
 \Function{attempt}{puzid}
   \State nonce ← sample random
   \State $m$ ← listen for valid transactions
   \State π ← prove \Call{C}{(puzid, $m$), (nonce, $0^{|m|}$)}
   \Comment{hiding (nonce, $0^{|m|}$)}
   \State \Return (π, $m$)
 \EndFunction
 \State
 \Function{verify}{puzid, solution}:
    \State (π, $m$) ← solution
    \State check that π proves $C(($puzid, $m), \cdot)$
 \EndFunction
\end{algorithmic}

\begin{theorem}
The above scheme is non-outsourceable.
\end{theorem}
\IEEEproof 
Suppose the existence of functions $\unn{attempt\_server}$, $\unn{check\_bill}$, and $\unn{detect}$ satisfy the {\em feasible}, {\em detectable}, and {\em non-interference} properties of a watermark-billable-work scheme. We will show a contradiction by constructing a witness distinguisher for the NIZK scheme. First we note that $\unn{attempt}($puzid$)$ runs in $t$ steps, and therefore by {\em non-interference} produces a detectable solution with probability less than $(1-ε)2^{-d}$. Next we apply the extractability of the NIZK scheme to $\Adv_{\unn{attempt\_server}}$ and construct an alternate $\Adv'$, which we then show is distinguishable from $\Adv_{\unn{attempt}}$ yet differs only in its (hidden) witness.
\begin{algorithmic}[0]
  \State
  \Function{$\Adv'$}{puzid, $sk$}
     \State (bill, $(π', m')) ← \Adv_{\unn{attempt\_server}}($puzid, $sk$)
     \State (nonce, $m) ← \mathcal{E}_{\Adv_{\unn{attempt\_server}}}$($π'$, (puzid, $sk$))
     \State π ← prove \Call{C}{(puzid, $m$), (nonce, $m⊕m'$)}
     \State \Return (bill, $(π, m))$
  \EndFunction
\end{algorithmic}
 \anote{Assume that extraction preserves exactly the number $t$ of steps (not just polynomially related).}  $\Adv'$ also takes $t$ steps, and outputs a bill (and/or a solution) whenever $\Adv_{\unn{attempt\_server}}($puzid, $sk)$ does. Because $\Adv'$ is {\em feasible}, it outputs a solution with probability $2^{-d}$; since it is {\em detectable}, it outputs a watermarked solution with similar probability. Therefore $\unn{detect\_watermark}$ can be used to distinguish between $\unn{attempt}$ and $\Adv'$ with advantage $ε$. But $\Adv'$ differs from only $\Adv_{\unn{attempt}}$ in the choice of witness, so the distinguisher violates the statistical zero-knowledge property of the NIZK.
\qed

\subsubsection{A Non-Outsourceable Storage Puzzle}

\anote{The pinocchio-based zero-knowledge puzzle construction goes here}



\end{document}


\section{Introduction}

The challenge is twofold: (1) as the protocol is open to the
public, we cannot rely on strong pre-established identities associated
uniquely to each user (which would simplify the matter and is the
standard model in distributed computing); and (2) due to economies of
scale, computational tasks are generally performed more efficiently
when resources are aggregated rather than dispersed. 

To address (1), we adapt a technique pioneered by Bitcoin: our
mechanism takes the form of a computational puzzle-solving
competition. We design the puzzle in such a way that it can be solved
most effectively only by 
correctly following the protocol (i.e., by storing the correct
data). 

The second aspect of the challenge is more difficult. We must
essentially {\em prevent outsourcing}. Our approach is motivated by
the observation that customers do not inherently *trust* the cloud
service provider, but rather delegate responsibility to the 
service provider only when it is efficient to enforce contracts to
that effect. Thus we would aim for a puzzle-competition protocol that
precludes the existence of a side-protocol by which a service provider
can prove to a client (or, perhaps more importantly, a judge or other
third party) that it is doing the puzzle-solving work that benefits the 
client. This approach seems likely to be thwarted, however, by recent
results on efficient private and verifiable computation for arbitrary
computations. We will proceed by supposing the existence of a poly-log
lower bound for the prover efficiency (i.e., the service providers
costs) of outsourced computation. We then adapt an approach based on
{\em signets}~\cite{signets}, such that any {\em easier} method of
outsourcing (short of universal outsourcing) makes the client
vulnerable to the server --- if the client trusts the service provider
with its computation, it also trusts the service provider with the
monetary reward.

\subsection{How Bitcoin Works}

Brief overview, include links to Bitcoin primer, Bitter-to-Better, Kroll and Felten, etc.

\subsection{Proof-of-Work and Hashcash}

\subsection{General Structure of Puzzle Competitions}

The general protocol structure we’ve discussed involves having a
trusted central party generate and publish a puzzle description in
each epoch. The participants try to find compute solutions to send to
the central party; the first participant to find a solution earns a
reward and the epoch ends.
\newline
\newline

%% \begin{algorithm}[h]
%%  \SetKwFunction{KwVerify}{scratch\_off}
%%  \SetKwFunction{KwSolve}{solve}
%%  $F_1,...F_n$ are the blocks of the $n$-block file we want stored\;
%%  $puz ← \tn{gen\_puz}(F, λ, \tn{epoch})$\;
%%  $pk,sk$ ← gen\_key()\;
%%   \KwSolve{puz}{
%%    \While{not solved}{
%%      nonce ← draw\_ticket($puz,pk$)\;
%%      \If{scratch\_off(nonce,λ) is valid}{
%%        this is a winner
%%      }
%%    }
%%  }
%%  \caption{General form of puzzle}
%% \end{algorithm}









\subsection{Hosted Mining Protocol}

Protocol for hosted mining with ordinary Bitcoin.

A puzzle could be made that would allow an outsourcing arrangement to work even better. Under the current scheme, it is possible for the server to withhold winning solutions. This may not be significant enough concern to discourage outsourcing, since there is apparently no incentive for service provider to do so. Nevertheless, we may construct a puzzle consisting of two phases, which has essentially the same effectiveness, yet allows the client to unblind each partial solution as a fair attempt.

%% \begin{algorithm}[h]
%%   \DontPrintSemicolon
%%   \SetKwFunction{KwCheck}{verify}
%%   \SetKwFunction{KwScratch}{scratch\_off}
%% \KwScratch{prevblock,nonce,data}{:\;
%% \quad  $root ← \hash(data)$\;
%% \quad  $h ← \hash(prevblock ∥ root ∥ nonce)$\;
%% \quad  \Return $h < 2^{-d}$
%% }\;

%% \KwCheck{prevblock,solution}{
%%   \;
%% }\;
%%    \caption{Standard bitcoin puzzle}
%% \end{algorithm}

\subsection{Strawman Non-Outsourceable Puzzle }
We can design a puzzle where the receipt of the reward is bound after the puzzle. This allows the miner to steal the puzzle. However even if the reward can be stolen, stealing the reward is detectable. It would be possible, for example, for the service provider to post an insurance bond that will be automatically paid out if it is caught.

\subsection{Non-Outsourceable Puzzle}


\section{Grafted Proof-of-Storage Puzzle}

We discuss techniques for the {\em crowdsourcing} of
storage. While {\em outsourcing} is a popular approach for reducing
costs by exploiting economies of scale and amortization, our 
primary goal is fault tolerance by replicating storage to devices that
are maximally dispersed, both spatially and administratively.
Previous work has focused on enabling service providers to prove they
replicate data across multiple hard drives, thus defending against
random device failures. However, this does not defend against
correlated failures of multiple drives, such as a data-center fire, or
a the service provider going bankrupt. Our goal is to achieve the
replication of
storage across as many independent administrative domains as possible,
and thereby enjoy minimal correlation of failures. Our approach,
inspired by Bitcoin, is to construct a mechanism for rewarding
participation, such that many individual
users are incentivised to participate (and participate correctly).

\subsection{Proof-of-Retrievability}

\subsection{Grafted Proof-of-Retrievability Puzzle}

This is a construction that leads to a poor outcome
  where the rational agents just pay a central server to do all of the
  work and they proportionally receive the benefit. This resembles
  the current Bitcoin puzzle, except based on a proof of retrievability.

%% \begin{algorithm}[h]
%%  $F_1,...F_n$ are the blocks of the $n$-block file we want stored\;
%%  $puz ← \tn{gen\_puz}(F, λ, \tn{epoch})$\;
%%  $pk,sk$ ← gen\_key()\;
%%  $λ₁+λ₂ = λ$ are outsource parameters chosen by the client\;
%%  \While{not solved}{
%%    nonce ← draw\_ticket($puz,pk$)\;
%%    $q_1,...q_d ← $gen\_challenge($puz$,nonce)\;
%%    $w₁ ← \hash(puz ∥ \tn{nonce} ∥ F_{q_1} ∥ ... ∥ F_{q_d}) ∈ [0,1]$ \;
%%    $w₂ ← sign(sk, (puz ∥ \tn{nonce}))$ \;
%%    \If{$w₁ < 2^{-λ₁}$ and $w₂ < 2^{-λ₂}$}{
%%      this is a winner\;
%%      transmit $w₂$ and nonce\;
%%    }
%%  }
%%  \caption{Strawman puzzle for which there exists an efficient
%%    publicly verifiable outsourcing contract}
%% \end{algorithm}


\section{Implementation and Evaluation}

We implemented a proof of concept of a hosted Bitcoin mining system. This allows a server to prove to a client that it is doing work that can only benefit the client.

We implemented the repaired  proof 







\subsection{RSA-Hourglass PoR Puzzle for Dispersed Computation}

%% \begin{algorithm}[h]
%%  $F_1,...F_n$ are the blocks of the $n$-block file we want stored\;
%%  $puz ← \tn{gen\_puz}(F, λ, \tn{epoch})$\;
%%  $pk,sk$ ← gen\_key()\;
%%  $G_1,...,G_n$ are watermark-encoded blocks with $sk$\;
%%  $H_1,...,H_n$ are made by applying inverse RSA to $G$ with trapdoor $sk$\;
%%  \While{not solved}{
%%    nonce ← draw\_ticket($puz,pk$)\;
%%    $q_1,...q_d ← \tn{gen\_challenge}(puz,\tn{nonce})$\;
%%    $w ← \hash(puz ∥ \tn{nonce} ∥ H_{q_1} ∥ ... ∥ H_{q_d}) ∈ [0,1]$ \;
%%    \If{$w < 2^{-λ}$}{
%%      this is a winner\;
%%      transmit $pk$ and a zk proof that $H_{q_i}$ is constructed
%%      correctly (without revealing $sk$, i.e., $G$)\;
%%    }
%%  }
%%  \caption{Strawman puzzle for which there exists an efficient
%%    publicly verifiable outsourcing contract}
%% \end{algorithm}

\section{Partial and Unlinkable PoR Puzzle}

The goal of the partial and unlinkable puzzle is to allow an
individual participant with less than the capacity to store the entire
file to select only a subset of the blocks and store those. However,
the winning puzzle solution shouldn't be linkable to the particular
subset; as otherwise, to maintain privacy, the participant would have
to download a different subset immediately after winning.

%% \begin{algorithm}[h]
%%  $F_1,...F_n$ are the blocks of the $n$-block file we want stored\;
%%  $puz ← \tn{gen\_puz}(F, λ, \tn{epoch})$\;
%%  $pk,sk$ ← gen\_key()\;
%%  player selects a private identity (random seed) $a$\;
%%  secret PRF is $g_a(j) = f_a(j) \mod n = (j^a \mod p) \mod n$\;
%%  at setup, player stores $F_{g_a(2)} … F_{g_a(k+1)}$\;
%%  \While{not solved}{
%%    nonce ← random()\;
%%    $Y ← (g^a \ h^\tn{nonce})$\;
%%    $c_1,...c_d ← $ draw $d$ random elements $∈ 1...k$ using $Y$ as seed\;
%%    $q_1,...q_d ← g_a(c_1),...g_a(c_d)$\;
%%    $w ← \tn{zk\_sign}(sk, (puz ∥ \tn{nonce} ∥ F_{q_1} ∥ ... ∥ F_{q_d}))$\;
%%    \If{$w < 2^{-λ}$}{
%%      this is a winner\;
%%      transmit zk proof that $c$ matches $q$\;
%%    }
%%  }
%% \caption{Partial and unlinkable PoR puzzle}
%% \end{algorithm}

